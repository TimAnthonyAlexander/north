import type { Provider, ToolSchema, Message } from "../provider/index";
import type { ToolRegistry } from "../tools/registry";
import type { Logger } from "../logging/index";

interface DiscoveryTopic {
    id: string;
    title: string;
    prompt: string;
}

const DISCOVERY_TOPICS: DiscoveryTopic[] = [
    {
        id: "summary",
        title: "Project Summary",
        prompt: "Find out for this project what it is, who it is for, what the main user workflows are, and what it explicitly does not do. Write a short, concrete summary.",
    },
    {
        id: "architecture",
        title: "Architecture Map",
        prompt: "Find out for this project what the major modules/subsystems are, how they relate, and where the main entry points are (apps, commands, servers, workers). Summarize the structure in a compact map.",
    },
    {
        id: "conventions",
        title: "Code Style and Conventions",
        prompt: "Find out for this project what the coding conventions are: naming, folder layout, formatting, patterns for errors/logging, and any lint/format rules. Write rules the assistant should follow when editing code here.",
    },
    {
        id: "vocabulary",
        title: "Domain Model Vocabulary",
        prompt: "Find out for this project the key domain concepts and entities, the terms used in code, and where those concepts live in the repo. List the vocabulary and point to the canonical locations.",
    },
    {
        id: "data_flow",
        title: "Data Flow and State",
        prompt: "Find out for this project where state is stored and how data flows through the system (persistence, caches, files, in-memory state). Describe the main data paths and boundaries.",
    },
    {
        id: "dependencies",
        title: "External Dependencies and Integrations",
        prompt: "Find out for this project the important dependencies and external integrations (frameworks, libraries, services, APIs). Note where configuration lives and where integration code is implemented.",
    },
    {
        id: "workflow",
        title: "Build, Run, and Test Workflow",
        prompt: "Find out for this project how to run it locally, how to run tests, lint/format, and build/release. Provide the core commands and where to look for details.",
    },
    {
        id: "hotspots",
        title: "Hot Spots and Change Patterns",
        prompt: "Find out for this project which files and areas change most often and what kinds of changes typically happen there. Identify any sensitive areas that need extra caution.",
    },
    {
        id: "playbook",
        title: "Common Tasks Playbook",
        prompt: "Find out for this project where to implement common changes (new feature, new endpoint, new UI view, new command, new background job, new migration/config). Write a short 'where to put things' playbook.",
    },
    {
        id: "safety",
        title: "Safety Rails and Footguns",
        prompt: "Find out for this project the known pitfalls: security constraints, performance traps, invariants, migration gotchas, cross-platform issues, and any strict rules. Write a checklist the assistant should respect.",
    },
];

const READ_ONLY_TOOLS = [
    "list_root",
    "read_file",
    "search_text",
    "find_files",
    "read_readme",
    "detect_languages",
    "hotfiles",
    "get_line_count",
    "get_file_symbols",
    "get_file_outline",
];

export async function runLearningSession(
    repoRoot: string,
    toolRegistry: ToolRegistry,
    provider: Provider,
    logger: Logger,
    onProgress: (percent: number, topic: string) => void
): Promise<string> {
    const allSchemas = toolRegistry.getSchemas();
    const readOnlySchemas = allSchemas.filter((schema) => READ_ONLY_TOOLS.includes(schema.name));

    const sections: string[] = [];

    for (let i = 0; i < DISCOVERY_TOPICS.length; i++) {
        const topic = DISCOVERY_TOPICS[i];
        const percent = Math.round(((i + 1) / DISCOVERY_TOPICS.length) * 100);

        onProgress(percent, topic.title);

        try {
            const response = await queryTopicWithTools(
                topic,
                readOnlySchemas,
                provider,
                toolRegistry,
                repoRoot,
                logger
            );

            if (response && response.trim()) {
                sections.push(`## ${topic.title}\n\n${response.trim()}`);
            } else {
                sections.push(`## ${topic.title}\n\nNo information gathered for this topic.`);
            }
        } catch (err) {
            const errorMsg = err instanceof Error ? err.message : String(err);
            logger.error("learning_topic_error", err as Error, {
                topicId: topic.id,
                topicTitle: topic.title,
            });
            sections.push(`## ${topic.title}\n\nLearning error: ${errorMsg.slice(0, 200)}`);
        }
    }

    const profileHeader = "# Project Profile\n\nGenerated by North project learning.\n\n";
    return profileHeader + sections.join("\n\n");
}

async function queryTopicWithTools(
    topic: DiscoveryTopic,
    toolSchemas: ToolSchema[],
    provider: Provider,
    toolRegistry: ToolRegistry,
    repoRoot: string,
    logger: Logger
): Promise<string> {
    const conversationMessages: Message[] = [];

    conversationMessages.push({
        role: "user",
        content: topic.prompt,
    });

    const maxIterations = 5;
    let iteration = 0;
    let lastAssistantText = "";

    while (iteration < maxIterations) {
        iteration++;

        const streamResult = await new Promise<{
            text: string;
            toolCalls: Array<{ id: string; name: string; input: unknown }>;
            stopReason: string | null;
        }>((resolve, reject) => {
            let text = "";
            const toolCalls: Array<{ id: string; name: string; input: unknown }> = [];

            provider
                .stream(
                    conversationMessages,
                    {
                        onChunk: (chunk) => {
                            text += chunk;
                        },
                        onToolCall: (toolCall) => {
                            toolCalls.push(toolCall);
                        },
                        onComplete: (result) => {
                            resolve({
                                text: result.text,
                                toolCalls: result.toolCalls,
                                stopReason: result.stopReason,
                            });
                        },
                        onError: (error) => {
                            reject(error);
                        },
                    },
                    {
                        tools: toolSchemas,
                        systemOverride:
                            "You are helping North learn about a codebase. Use tools to explore the code. Do not narrate your exploration steps. After using tools, provide only the final concise answer as a summary with bullet points. Be direct and factual.",
                    }
                )
                .catch(reject);
        });

        lastAssistantText = streamResult.text;

        if (streamResult.stopReason === "tool_use" && streamResult.toolCalls.length > 0) {
            conversationMessages.push(
                provider.buildAssistantMessage(streamResult.text, streamResult.toolCalls)
            );

            const toolResults: Array<{ toolCallId: string; result: string; isError?: boolean }> =
                [];

            for (const toolCall of streamResult.toolCalls) {
                const result = await toolRegistry.execute(toolCall.name, toolCall.input, {
                    repoRoot,
                    logger,
                });

                let resultContent: string;
                if (result.ok && result.data) {
                    if (typeof result.data === "string") {
                        resultContent = result.data.slice(0, 5000);
                    } else {
                        resultContent = JSON.stringify(result.data).slice(0, 5000);
                    }
                } else {
                    resultContent = `ERROR: ${result.error || "Unknown error"}`;
                }

                toolResults.push({
                    toolCallId: toolCall.id,
                    result: resultContent,
                    isError: !result.ok,
                });
            }

            conversationMessages.push(provider.buildToolResultMessage(toolResults));
        } else {
            break;
        }
    }

    return lastAssistantText.trim();
}
