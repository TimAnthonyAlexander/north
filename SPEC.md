# North Spec (v0)

## 1) Product summary

North is a terminal assistant for codebases:
- You chat in a minimal Ink TUI
- Claude streams responses
- Claude can request host tools (read/search/edit/shell)
- The host validates and executes tools
- All file edits are shown as inline diffs for approval before writing

Supported platforms:
- macOS
- Linux

Packaging goal:
- Self-contained binary built with Bun

Runtime and language:
- Bun
- TypeScript only

Model:
- Claude only
- Default: Sonnet 4.5
- Streaming required

## 2) UX requirements

### 2.1 Conversation flow
- Main UI is a single conversational timeline.
- User can type multiline input.
- Enter sends.
- Shift+Enter inserts a newline.
- Assistant output streams (token streaming).

### 2.2 Tool visibility
- When the model proposes a tool call, the UI shows a compact "intent line" in the transcript, for example:
  - "Searching: `foo` in `src/`"
  - "Preparing edits in `src/App.tsx`"
  - "Command requested: `pnpm test`"
- Tool results are either:
  - Shown inline in a compact form
  - Or summarized with a "details available" expansion if large

### 2.3 Inline diff review (must-have)
- Any change to the filesystem must be reviewed via an inline diff viewer.
- The diff viewer appears in-flow, not as a separate screen.
- The user can:
  - Accept (apply edits)
  - Reject (discard edits)
- No partial acceptance in v0. Keep it simple.

### 2.4 Shell command approvals
Every shell command must be gated by an approval prompt with:
- "Run this time"
- "Always execute"
- "Deny"

Rules:
- "Run this time": execute now, ask again next time.
- "Always execute": persist an allow rule, then execute now, and auto-execute future identical commands in this project.
- "Deny": do not execute, return a denied result to the model.

The allow rule persistence is per-project.

## 3) Architecture (KISS module boundaries)

Keep the implementation as a small set of modules with single responsibility.

### 3.1 Modules
1) UI (Ink)
- Renders transcript, composer, prompts, diffs, status.

2) Orchestrator (Core loop)
- Owns conversation state
- Sends messages to the model
- Receives streaming output
- Handles tool calls and retries

3) Provider (Anthropic)
- Streaming client
- Tool calling protocol adapter
- Token budgeting and truncation rules

4) Tool Registry
- In-process registry mapping tool name -> handler
- Each tool has:
  - name
  - input schema
  - execute()
  - approval policy: none | shell | write

5) Repo Layer
- Resolves repo root
- Enforces .gitignore-aware reads/searches
- Reads and writes files safely
- Computes diffs

6) PTY Shell Service
- Creates and maintains 1 persistent PTY session per project
- Executes commands inside that session
- Captures stdout/stderr/exit code

7) Storage
- Project config
- Allow rules
- Memory
- Project card cache
- Logging

### 3.2 Data flow (high level)
- User input -> Orchestrator -> Model (stream) -> UI updates
- Model requests tool -> Orchestrator -> Tool registry -> tool handler
- If tool needs approval -> UI prompt -> user decision -> continue
- Tool returns result -> Orchestrator -> appended to model context -> model continues

## 4) Storage layout (simple and explicit)

Prefer local files over sqlite for v0.

### 4.1 Project-local folder
At repo root:
- `.north/`
  - `project.json` (project settings, optional)
  - `allowlist.json` (shell allow rules)
  - `memory.json` (project memory)
  - `cache.json` (project card cache)

Rationale:
- Easy to inspect and delete
- Version control friendly if users choose to add it to gitignore
- Simple mental model

### 4.2 Global folder
Use XDG-like locations where possible.

Recommended:
- Config: `~/.config/north/config.json`
- Memory: `~/.local/share/north/memory.json`
- Logs: `~/.local/state/north/north.log`

macOS fallback if needed:
- Use the same paths, unless permissions or conventions require otherwise. Keep it consistent and documented.

## 5) Model interaction design

### 5.1 System posture
- The model must not "edit files" in free-form output.
- The model must propose tool calls for side effects.
- The host is strict: deterministic edits only.

### 5.2 Context strategy
Always include:
- Short product rules (KISS, deterministic edits, approvals)
- Project card (readme snippet, root tree, language composition, hotfiles)
- Relevant file snippets discovered via tools
- A rolling conversation summary (internal, generated by the host when needed)

User can reference files via:
- Natural language (the host will rely on search tools)
- @mentions (optional behavior later, not required for v0)

### 5.3 Token discipline
- Avoid dumping large files into context.
- Prefer:
  - targeted line ranges
  - search hits
  - minimal excerpts
- If the model needs more, it should ask for more via tools.

## 6) Tools (v0 set)

Tools are the product. Keep the set small but complete.

### 6.1 Read and navigate tools (no approval)
1) `list_root`
- Purpose: list root-level entries of repo, respecting .gitignore
- Input: none
- Output: array of entries with type (file/dir)

2) `find_files`
- Purpose: find files by glob-like pattern
- Input: { "pattern": string, "limit": number }
- Output: array of file paths

3) `search_text`
- Purpose: ripgrep-like search
- Input: { "query": string, "path": string | null, "regex": boolean, "limit": number }
- Output: array of matches { path, line, column, preview }

4) `read_file`
- Purpose: read file content
- Input: { "path": string, "range": { "start": number, "end": number } | null }
- Output: { path, content, startLine, endLine }

5) `read_readme`
- Purpose: pick README.* and return a manageable excerpt
- Input: none
- Output: { path, content }

### 6.2 Repo context helpers (no approval)
6) `detect_languages`
- Purpose: approximate language composition by file extension and size
- Input: none
- Output: array { language, bytes, percent }

7) `hotfiles`
- Purpose: approximate most important files
- Heuristic for v0:
  - If git exists: use recent commit frequency and changed lines as signal
  - Else: fallback to "largest files under src/" or similar minimal heuristic
- Input: { "limit": number }
- Output: array { path, score, reason }

### 6.3 Editing tools (write approval required)
Edits must be deterministic and fail fast when anchors do not match.

All write tools return:
- A proposed diff (unified or a custom minimal diff) for UI review
- A "canApply" boolean
- Errors if validation fails

8) `edit_replace_exact`
- Input: { "path": string, "old": string, "new": string, "expectedOccurrences": number | null }
- Rules:
  - Must match exact `old` including whitespace
  - If expectedOccurrences is set, it must match exactly
- Output: { diff, canApply, stats }

9) `edit_insert_at_line`
- Input: { "path": string, "line": number, "content": string }
- Output: { diff, canApply, stats }

10) `edit_create_file`
- Input: { "path": string, "content": string, "overwrite": boolean }
- Output: { diff, canApply, stats }

11) `edit_apply_batch`
- Purpose: apply multiple edits in one transaction and show one review
- Input: { "edits": [ { toolName, args } ] }
- Rules:
  - Validate all edits first
  - Produce diffs grouped by file
  - If any edit fails, nothing is applied
- Output: { diffsByFile, canApply, stats }

### 6.4 Shell tool (shell approval required)
12) `shell_run`
- Input: { "command": string, "cwd": string | null, "timeoutMs": number | null }
- Behavior:
  - Executes in persistent PTY session
  - Returns stdout, stderr, exitCode
- Output: { stdout, stderr, exitCode, durationMs }

## 7) Editing pipeline (the reliability core)

This is the canonical flow for any file changes.

1) Model requests context (read/search/find).
2) Model proposes deterministic edits via write tools.
3) Host validates edits against current file contents.
4) Host generates diff(s) for review.
5) UI prompts user: Accept or Reject.
6) If Accept:
   - Host applies edits atomically (per batch) and writes files.
7) If Reject:
   - Host applies nothing and returns a rejected result to the model.
8) Orchestrator continues the loop.

Failure behavior:
- If validation fails (anchor not found, file missing, etc), return a structured error that encourages the model to read more context and retry.

No fuzzy matching in v0. Exactness is the product reliability lever.

## 8) Shell approval and allowlist behavior

Allowlist rules live in `.north/allowlist.json`.

Rule format should be extremely simple:
- Match on exact command string

Example:
{
  "allowedCommands": [
    "pnpm test",
    "bun test",
    "composer test"
  ]
}

When a command is requested:
- If command is in allowlist: execute immediately
- Else: prompt user
  - "Always execute" adds it to allowlist then runs

## 9) Logging

A single append-only log file.

Log events include:
- app start and version
- repo root detected
- model requests: model name, request id, token estimates if available
- tool calls: tool name, inputs (redacted where needed), duration, success/failure
- approvals: decisions, command strings, edited file paths
- errors: stack traces, recoverable vs fatal

Redaction:
- Never log API keys.
- Avoid logging full file contents. Log file paths and small metadata only.

## 10) CLI shape (minimal)

Primary command:
- `north` (interactive)

Optional flags:
- `--path <repoRoot>` (override repo root detection)
- `--log-level info|debug` (debug includes more tool metadata, still avoid content dumps)
- `--model sonnet-4.5` (default anyway)

Slash commands in UI (v0):
- `/help`
- `/clear` (clears transcript display, not memory)
- `/memory` (show current memory entries)
- `/allowlist` (show allowed commands)
- `/model` (show current model)

## 11) Future MCP compatibility (do not implement now)

Constraint:
- Tool registry should be shaped so MCP can be added later without rewriting core logic.

Practical rule:
- Keep tool definitions declarative (name, schema, approval policy).
- Keep invocation and results strictly structured JSON.


